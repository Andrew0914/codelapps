export const meta = {
  date: new Date(" 2023-08-30"),
  title: "La meta de las pruebas unitarias",
  subtitle: "Unit testing, principios, prÃ¡cticas y patrones | ðŸ“– Resumen",
  excerpt:
    "Por mucho tiempo desde que se impulso la prÃ¡ctica de hacer pruebas unitarias al software, la pregunta era **Â¿Debemos hacer pruebas unitarias?.**",
  author: "Andrew GM",
  thumbnail: "/images/posts/unitest_tendency.png",
  url: "/blog/meta-de-las-prubas-unitarias",
  tags: [
    {
      name: "unit testing",
      destiny: "tag/unit-testing",
    },
  ],
  recommendations: [{ name: " Sample", url: "../sample" }],
};

### El estado actual del unit testing.

Por mucho tiempo desde que se impulso la prÃ¡ctica de hacer pruebas unitarias al software, la pregunta era **Â¿Debemos hacer pruebas unitarias?.**

Sin embargo este empuje tuvo mucho Ã©xito y ahora todo programador que se diga ser profesional o todo aquel que desee serlo debe conocer y practicar
el hacer pruebas unitarias a su cÃ³digo, asÃ­ mismo para las compaÃ±Ã­as que hacen productos profesionales se volviÃ³ obligatorio realizar pruebas unitarias,
lo cual convierte esa pregunta inicial a **Â¿CÃ³mo hacer una buena prueba unitaria?**

### Â¿CuÃ¡l es el objetivo de las pruebas unitarias?

Si bien se dice que hacer pruebas unitarias a tu software mejoran el diseÃ±o del mismo, este solo es un buen efecto secundario, realmente
**lo que se busca con las pruebas unitarias es habilitar el crecimiento sostenible de un proyecto de software**.
Por ejemplo: agregar una nueva funcionalidad, o corregir algÃºn bug con la seguridad de que no romperÃ¡s el resto de cosas en tu sistema.
Estas posibles rupturas son conocidas como Â«regresionesÂ«, las pruebas unitarias sirven como una red de seguridad y previenen la tendencia del software a deteriorarse.
El no hacer pruebas unitarias provocarÃ¡ que el progreso de tu sistema no sea sostenible, mientras que con pruebas unitarias podemos generar un progreso certero, lo
mismo sucede con malas pruebas unitarias, aunque de inicio si disminuyen la velocidad en que tu software se deteriora, al final se comportan como si no realizaras
pruebas ya que no respaldan adecuadamente tu sistema.

<Image
  alt="Unit tests tendency"
  width={306}
  height={185}
  src="/images/posts/unitest_tendency.png"
  className="round--sm my--3"
/>

### Las mÃ©tricas de cobertura como medida de una buena calidad de suite de pruebas unitarias

Existen dos mÃ©tricas de cobertura populares que son el Â«code coverageÂ» y el _"branch coverage"_, estas mÃ©tricas nos indican que tanto de nuestra base cÃ³digo se esta
ejecutando a travÃ©s de las pruebas; la creencia general es que una mayor cobertura es mejor y que estamos teniendo un buen nivel de pruebas unitarias, pero la realidad no es tan simple.
El Â«code coverageÂ» o Â«test coverageÂ» es el mÃ¡s popular de los 2, y se determina de la siguiente manera:

**code coverage** = _executed lines / total lines_

Ejemplo:

```java
/* Test code */
public void test(){
    boolean result = isNameLong("abc");
    assertFalse(result); // esta ejecutando 4/5 (la 8,9,11 y 12) lineas = 80%
}

/*Source code*/
public static boolean isNameLong(String name){
    if(name.length > 5) //covered by test
        return true; // no covered
    return false; //covered by test
}
```

Podemos darnos cuenta que se estÃ¡n ejecutando 4/5 (la 8,9,11 y 12) lineas = 80% de lÃ­neas con la prueba, pero si nosotros refactorizamos el mÃ©todo bajo prueba algo asÃ­:

```java
/*Source code*/
public static boolean isNameLong(String name){
    return name.length > 5 //covered by test
}
```

podrÃ­amos estar cubriendo 3/3 lineas teniendo asÃ­ un 100% de code coverage.

Por otro lado el *Â«branch coverageÂ» *en lugar de medir la cantidad plana total de lineas ejecutadas, mide la cantidad de ramas que toca en funcion de las estructuras de control como un `if/switch`.

**branch coverage** = ramas tocadas / total de ramas

```java
/*Source code*/
public static boolean isNameLong(String name){
    return name.length > 5
}

/* Test code */
public void test(){
    boolean result = isNameLong("abc");
    assertFalse(result);
}
```

En el siguiente diagrama vemos los dos posibles caminos que puede tomar nuestro cÃ³digo bajo prueba:

<Image
  alt="Branch coverage"
  width={356}
  height={235}
  src="/images/posts/branch_coverage.png"
  className="round--sm my--3"
/>

Vemos que hay dos posibilidades de ejecuciÃ³n (2 caminos Ã³ 2 ramas), y en nuestra prueba estamos pasando a travÃ©s de 1 por lo cual estamos teniendo 1/2 ramas tocas = 50% de branch coverage.

El problema de tomar las mÃ©tricas de cobertura como medidas de calidad es que los nÃºmeros o porcentajes arrojados pueden ser engaÃ±osos, los ejemplos anteriores son simples, pero si nosotros tuviÃ©ramos algo asÃ­:

```java
public static boolean isNameLong(String name){
    boolean wasNameLong = false
    if(name.length > 5) {
        wasNameLong = true; // no guaranteed
        return true;
    }
    return false;
}

/* Test code */
public void test(){
    boolean result = isNameLong("abcdef");
    assertFalse(result);
}
```

Vemos que aunque 6/7= 85% lÃ­neas estÃ¡n siendo ejecutadas, solamente se esta probando implÃ­citamente la lÃ­nea con el return, no garantizando que por ejemplo wasNameLong tenga el valor correcto, lo mismo para la cantidad de ramas tocadas que en este ejemplo tambiÃ©n es 50% ya que solo esta probando cuando la condiciÃ³n del if es verdadera.

Podemos darnos cuenta que si bien son Ãºtiles estas mÃ©tricas suelen ser un excelente indicador negativo pero un mal indicador positivo de la calidad de tus pruebas, es decir, si los porcentajes son bajos si puede ser indicador de que tienes muchas parte de tu cÃ³digo sin probar, pero por el contrario el tener un alto porcentaje no indica que tienes una buena suite de pruebas.

Por eso es importante no tener como objetivo un determinado porcentaje de cobertura si no mas bien una buena suite de pruebas que aporten valor a tu sistema y lo respalden de manera adecuada, verificando las partes mÃ¡s importantes o crÃ­ticas de tu software.

### Â¿QuÃ© hace una buena suite de pruebas unitarias?

- Hacer pruebas tiene que ser parte del ciclo de desarrollo.
- La suite de pruebas debe tener como objetivo las partes mas importantes o crÃ­ticas de tu sistema.
- Debe proveer el mÃ¡ximo valor con el mÃ­nimo costo de mantenimiento.

En general se tiene que estar realizando pruebas constantemente como parte del ciclo de desarrollo a las partes mÃ¡s crÃ­ticas de nuestro sistema a medida que las vamos construyendo, las partes crÃ­ticas suele ser la lÃ³gica de negocio, dejando de lado cÃ³digo de infraestructura, condigo o dependencias externas y cÃ³digo de integraciÃ³n, reconociendo si la prueba realmente nos aporta valor o respalda adecuadamente lo que estamos verificando.

> EntrarÃ© en mÃ¡s detalle en prÃ³ximos capÃ­tulos de este post que es un resumen y mi entendimiento del libro: [Â«Unit testing: principles, pratices and patternsÂ» por Vladimir Khorikov de la editorial Manning.](https://www.manning.com/books/unit-testing)
